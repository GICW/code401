{"ast":null,"code":"import * as React from 'react';\nimport React__default, { Fragment, useRef, useState, useMemo, useEffect } from 'react';\n\n/**\n * Renders a React component while also checking whether the children are a function or not\n * @param props Props of the component to render\n */\nvar render = function render(props) {\n  if (typeof props.children === 'function') {\n    return React__default.createElement(Fragment, null, props.children());\n  }\n  return React__default.createElement(Fragment, null, props.children || null);\n};\n\n/**\n * If the `<Case />` is the first one to have its condition evaluates to true\n * inside the parent `<Switch />` it will be the only rendered.\n * @param props The props to pass down to the `<Case />` component\n */\nvar Case = function Case(_ref) {\n  var _ref$children = _ref.children,\n    children = _ref$children === void 0 ? null : _ref$children;\n  return render({\n    children: children\n  });\n};\n\n/**\n * If no `<Case />` have its condition evaluates to true inside the parent `<Switch />`,\n * the first `<Default />` will be the only one rendered.\n * @param props The props to pass down to the `<Default />` component\n */\nvar Default = function Default(_ref) {\n  var _ref$children = _ref.children,\n    children = _ref$children === void 0 ? null : _ref$children;\n  return render({\n    children: children\n  });\n};\n\n/**\n * Must only contain a single child, which it renders as-is.\n * Should not be used outside of an `<If />` block.\n * @param props The props to pass down to the `<Else />` component\n */\nvar Else = function Else(props) {\n  return render(props);\n};\n\n/**\n * Must contain only a single child, which it renders as-is.\n * Should not be used outside of an `<If />` block whose condition prop is a promise.\n * @param props The props to pass down to the `<Fallback />` component\n */\nvar Fallback = function Fallback(props) {\n  return render(props);\n};\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) {\n  try {\n    var i = n[a](c),\n      u = i.value;\n  } catch (n) {\n    return void e(n);\n  }\n  i.done ? t(u) : Promise.resolve(u).then(r, o);\n}\nfunction _asyncToGenerator(n) {\n  return function () {\n    var t = this,\n      e = arguments;\n    return new Promise(function (r, o) {\n      var a = n.apply(t, e);\n      function _next(n) {\n        asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n);\n      }\n      function _throw(n) {\n        asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n);\n      }\n      _next(void 0);\n    });\n  };\n}\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\nfunction _regeneratorRuntime() {\n  _regeneratorRuntime = function () {\n    return r;\n  };\n  var t,\n    r = {},\n    e = Object.prototype,\n    n = e.hasOwnProperty,\n    o = \"function\" == typeof Symbol ? Symbol : {},\n    i = o.iterator || \"@@iterator\",\n    a = o.asyncIterator || \"@@asyncIterator\",\n    u = o.toStringTag || \"@@toStringTag\";\n  function c(t, r, e, n) {\n    return Object.defineProperty(t, r, {\n      value: e,\n      enumerable: !n,\n      configurable: !n,\n      writable: !n\n    });\n  }\n  try {\n    c({}, \"\");\n  } catch (t) {\n    c = function (t, r, e) {\n      return t[r] = e;\n    };\n  }\n  function h(r, e, n, o) {\n    var i = e && e.prototype instanceof Generator ? e : Generator,\n      a = Object.create(i.prototype);\n    return c(a, \"_invoke\", function (r, e, n) {\n      var o = 1;\n      return function (i, a) {\n        if (3 === o) throw Error(\"Generator is already running\");\n        if (4 === o) {\n          if (\"throw\" === i) throw a;\n          return {\n            value: t,\n            done: !0\n          };\n        }\n        for (n.method = i, n.arg = a;;) {\n          var u = n.delegate;\n          if (u) {\n            var c = d(u, n);\n            if (c) {\n              if (c === f) continue;\n              return c;\n            }\n          }\n          if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) {\n            if (1 === o) throw o = 4, n.arg;\n            n.dispatchException(n.arg);\n          } else \"return\" === n.method && n.abrupt(\"return\", n.arg);\n          o = 3;\n          var h = s(r, e, n);\n          if (\"normal\" === h.type) {\n            if (o = n.done ? 4 : 2, h.arg === f) continue;\n            return {\n              value: h.arg,\n              done: n.done\n            };\n          }\n          \"throw\" === h.type && (o = 4, n.method = \"throw\", n.arg = h.arg);\n        }\n      };\n    }(r, n, new Context(o || [])), !0), a;\n  }\n  function s(t, r, e) {\n    try {\n      return {\n        type: \"normal\",\n        arg: t.call(r, e)\n      };\n    } catch (t) {\n      return {\n        type: \"throw\",\n        arg: t\n      };\n    }\n  }\n  r.wrap = h;\n  var f = {};\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n  var l = {};\n  c(l, i, function () {\n    return this;\n  });\n  var p = Object.getPrototypeOf,\n    y = p && p(p(x([])));\n  y && y !== e && n.call(y, i) && (l = y);\n  var v = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(l);\n  function g(t) {\n    [\"next\", \"throw\", \"return\"].forEach(function (r) {\n      c(t, r, function (t) {\n        return this._invoke(r, t);\n      });\n    });\n  }\n  function AsyncIterator(t, r) {\n    function e(o, i, a, u) {\n      var c = s(t[o], t, i);\n      if (\"throw\" !== c.type) {\n        var h = c.arg,\n          f = h.value;\n        return f && \"object\" == typeof f && n.call(f, \"__await\") ? r.resolve(f.__await).then(function (t) {\n          e(\"next\", t, a, u);\n        }, function (t) {\n          e(\"throw\", t, a, u);\n        }) : r.resolve(f).then(function (t) {\n          h.value = t, a(h);\n        }, function (t) {\n          return e(\"throw\", t, a, u);\n        });\n      }\n      u(c.arg);\n    }\n    var o;\n    c(this, \"_invoke\", function (t, n) {\n      function i() {\n        return new r(function (r, o) {\n          e(t, n, r, o);\n        });\n      }\n      return o = o ? o.then(i, i) : i();\n    }, !0);\n  }\n  function d(r, e) {\n    var n = e.method,\n      o = r.i[n];\n    if (o === t) return e.delegate = null, \"throw\" === n && r.i.return && (e.method = \"return\", e.arg = t, d(r, e), \"throw\" === e.method) || \"return\" !== n && (e.method = \"throw\", e.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), f;\n    var i = s(o, r.i, e.arg);\n    if (\"throw\" === i.type) return e.method = \"throw\", e.arg = i.arg, e.delegate = null, f;\n    var a = i.arg;\n    return a ? a.done ? (e[r.r] = a.value, e.next = r.n, \"return\" !== e.method && (e.method = \"next\", e.arg = t), e.delegate = null, f) : a : (e.method = \"throw\", e.arg = new TypeError(\"iterator result is not an object\"), e.delegate = null, f);\n  }\n  function w(t) {\n    this.tryEntries.push(t);\n  }\n  function m(r) {\n    var e = r[4] || {};\n    e.type = \"normal\", e.arg = t, r[4] = e;\n  }\n  function Context(t) {\n    this.tryEntries = [[-1]], t.forEach(w, this), this.reset(!0);\n  }\n  function x(r) {\n    if (null != r) {\n      var e = r[i];\n      if (e) return e.call(r);\n      if (\"function\" == typeof r.next) return r;\n      if (!isNaN(r.length)) {\n        var o = -1,\n          a = function e() {\n            for (; ++o < r.length;) if (n.call(r, o)) return e.value = r[o], e.done = !1, e;\n            return e.value = t, e.done = !0, e;\n          };\n        return a.next = a;\n      }\n    }\n    throw new TypeError(typeof r + \" is not iterable\");\n  }\n  return GeneratorFunction.prototype = GeneratorFunctionPrototype, c(v, \"constructor\", GeneratorFunctionPrototype), c(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = c(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), r.isGeneratorFunction = function (t) {\n    var r = \"function\" == typeof t && t.constructor;\n    return !!r && (r === GeneratorFunction || \"GeneratorFunction\" === (r.displayName || r.name));\n  }, r.mark = function (t) {\n    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, c(t, u, \"GeneratorFunction\")), t.prototype = Object.create(v), t;\n  }, r.awrap = function (t) {\n    return {\n      __await: t\n    };\n  }, g(AsyncIterator.prototype), c(AsyncIterator.prototype, a, function () {\n    return this;\n  }), r.AsyncIterator = AsyncIterator, r.async = function (t, e, n, o, i) {\n    void 0 === i && (i = Promise);\n    var a = new AsyncIterator(h(t, e, n, o), i);\n    return r.isGeneratorFunction(e) ? a : a.next().then(function (t) {\n      return t.done ? t.value : a.next();\n    });\n  }, g(v), c(v, u, \"Generator\"), c(v, i, function () {\n    return this;\n  }), c(v, \"toString\", function () {\n    return \"[object Generator]\";\n  }), r.keys = function (t) {\n    var r = Object(t),\n      e = [];\n    for (var n in r) e.unshift(n);\n    return function t() {\n      for (; e.length;) if ((n = e.pop()) in r) return t.value = n, t.done = !1, t;\n      return t.done = !0, t;\n    };\n  }, r.values = x, Context.prototype = {\n    constructor: Context,\n    reset: function (r) {\n      if (this.prev = this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(m), !r) for (var e in this) \"t\" === e.charAt(0) && n.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = t);\n    },\n    stop: function () {\n      this.done = !0;\n      var t = this.tryEntries[0][4];\n      if (\"throw\" === t.type) throw t.arg;\n      return this.rval;\n    },\n    dispatchException: function (r) {\n      if (this.done) throw r;\n      var e = this;\n      function n(t) {\n        a.type = \"throw\", a.arg = r, e.next = t;\n      }\n      for (var o = e.tryEntries.length - 1; o >= 0; --o) {\n        var i = this.tryEntries[o],\n          a = i[4],\n          u = this.prev,\n          c = i[1],\n          h = i[2];\n        if (-1 === i[0]) return n(\"end\"), !1;\n        if (!c && !h) throw Error(\"try statement without catch or finally\");\n        if (null != i[0] && i[0] <= u) {\n          if (u < c) return this.method = \"next\", this.arg = t, n(c), !0;\n          if (u < h) return n(h), !1;\n        }\n      }\n    },\n    abrupt: function (t, r) {\n      for (var e = this.tryEntries.length - 1; e >= 0; --e) {\n        var n = this.tryEntries[e];\n        if (n[0] > -1 && n[0] <= this.prev && this.prev < n[2]) {\n          var o = n;\n          break;\n        }\n      }\n      o && (\"break\" === t || \"continue\" === t) && o[0] <= r && r <= o[2] && (o = null);\n      var i = o ? o[4] : {};\n      return i.type = t, i.arg = r, o ? (this.method = \"next\", this.next = o[2], f) : this.complete(i);\n    },\n    complete: function (t, r) {\n      if (\"throw\" === t.type) throw t.arg;\n      return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && r && (this.next = r), f;\n    },\n    finish: function (t) {\n      for (var r = this.tryEntries.length - 1; r >= 0; --r) {\n        var e = this.tryEntries[r];\n        if (e[2] === t) return this.complete(e[4], e[3]), m(e), f;\n      }\n    },\n    catch: function (t) {\n      for (var r = this.tryEntries.length - 1; r >= 0; --r) {\n        var e = this.tryEntries[r];\n        if (e[0] === t) {\n          var n = e[4];\n          if (\"throw\" === n.type) {\n            var o = n.arg;\n            m(e);\n          }\n          return o;\n        }\n      }\n      throw Error(\"illegal catch attempt\");\n    },\n    delegateYield: function (r, e, n) {\n      return this.delegate = {\n        i: x(r),\n        r: e,\n        n: n\n      }, \"next\" === this.method && (this.arg = t), f;\n    }\n  }, r;\n}\n\n/**\n * Must contain only a single child, which it renders as-is.\n * Should not be used outside of an `<If />` block.\n * @param props The props to pass down to the `<Then />` component\n */\nvar Then = function Then(props) {\n  return render(props);\n};\n\n/**\n * The MIT License (MIT)\n *\n * Copyright © `2020` `The Sapphire Community and its contributors`\n *\n * Source: https://github.com/sapphiredev/utilities/blob/main/packages/utilities/src/lib/isThenable.ts\n * Full license: https://github.com/sapphiredev/utilities/blob/main/LICENSE.md\n */\n/**\n * Verify if the input is a function.\n * @param input The function to verify\n */\nfunction isFunction(input) {\n  return typeof input === 'function';\n}\nfunction hasThen(input) {\n  return Reflect.has(input, 'then') && isFunction(input.then);\n}\nfunction hasCatch(input) {\n  return Reflect.has(input, 'catch') && isFunction(input[\"catch\"]);\n}\n/**\n * Verify if an object is a promise.\n * @param input The promise to verify\n */\nfunction isThenable(input) {\n  if (typeof input !== 'object' || input === null) return false;\n  return input instanceof Promise || input !== Promise.prototype && hasThen(input) && hasCatch(input);\n}\n\n/**\n * Compare two arrays without checking for possible nested properties\n * @param a Array to compare with b\n * @param b Array to compare with a\n * @returns True if arrays are identical, false if they are different\n */\nvar shallowArraysEqual = function shallowArraysEqual(a, b) {\n  if (!Array.isArray(a) || !Array.isArray(b)) throw new Error('shallowArraysEqual only accepts arrays as parameters');\n  if (a.length !== b.length) return false;\n  for (var i = 0; i < a.length; ++i) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n};\n/**\n * Create a CancellablePromise from a native Promise\n * @param promise The promise object to wrap\n * @returns Return value is an object of type CancellablePromise, with 2 properties:\n * - promise: a promise that can be left pending\n * - cancel: the function to use for cancelling the returned promise\n */\nvar createCancellablePromise = function createCancellablePromise(promise) {\n  if (!isThenable(promise)) {\n    throw new Error('Argument of createCancellablePromise should be a Promise');\n  }\n  var isCancelled = {\n    value: false\n  };\n  var wrappedPromise = new Promise(/*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(res, rej) {\n      var d;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            _context.next = 3;\n            return promise;\n          case 3:\n            d = _context.sent;\n            if (!isCancelled.value) {\n              res(d);\n            }\n            _context.next = 10;\n            break;\n          case 7:\n            _context.prev = 7;\n            _context.t0 = _context[\"catch\"](0);\n            if (!isCancelled.value) {\n              rej(_context.t0);\n            }\n          case 10:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee, null, [[0, 7]]);\n    }));\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }());\n  // Forward potential additional properties\n  Object.keys(promise).forEach(function (key) {\n    wrappedPromise[key] = promise[key];\n  });\n  return {\n    promise: wrappedPromise,\n    cancel: function cancel() {\n      isCancelled.value = true;\n    }\n  };\n};\n\n/**\n * Calls a function only once during component lifecycle;\n * When dependency array is provided, will call the function again if at least one of the dependencies changed\n * @param callback The function to execute only once\n * @param dependencies A list of dependencies whose value, if changed since last call,\n * will trigger the execution of the callback\n */\nvar useSingleton = function useSingleton(callback, dependencies) {\n  if (dependencies === void 0) {\n    dependencies = [];\n  }\n  var hasRan = useRef(false);\n  var lastDependencies = useRef([]);\n  // Parameters type check\n  if (typeof callback !== 'function') {\n    throw new Error(\"Incorrect callback parameter for useSingleton hook; expected a function, but got: '\" + typeof callback + \"'.\");\n  }\n  if (!Array.isArray(dependencies)) {\n    throw new Error(\"Incorrect dependencies parameter for useSingleton; expected an array, but got: '\" + typeof dependencies + \"'.\");\n  }\n  var hasDependencies = Array.isArray(dependencies) && dependencies.length > 0;\n  if (hasDependencies) {\n    // Has dependencies\n    var hasAnyDependencyChanged = !shallowArraysEqual(lastDependencies.current, dependencies);\n    if (hasAnyDependencyChanged) {\n      // Any dep has changed => overwrite last dependencies and execute callback\n      lastDependencies.current = dependencies;\n    } else if (hasRan.current) {\n      // No dep has changed => same behaviour as if no dependencies\n      return;\n    }\n  } else if (hasRan.current) {\n    // No dependencies\n    return;\n  }\n  callback();\n  hasRan.current = true;\n};\n\n/**\n * Is included in the `<If />` component, rendered when the condition prop of `<If />` is a Promise;\n * Renders the Fallback component, if contains any, until provided promise is fulfilled;\n * Renders `<Then />` when promise is fulfilled, `<Else />` when rejected\n */\nfunction IfAsync(_ref) {\n  var promise = _ref.promise,\n    _ref$keepAlive = _ref.keepAlive,\n    keepAlive = _ref$keepAlive === void 0 ? false : _ref$keepAlive,\n    children = _ref.children;\n  var _useState = useState(null),\n    isResolved = _useState[0],\n    setIsResolved = _useState[1];\n  var _useState2 = useState(null),\n    returnValue = _useState2[0],\n    setReturnValue = _useState2[1];\n  // Make promise cancellable\n  var cancellablePromise = useMemo(function () {\n    return createCancellablePromise(promise);\n  }, [promise]);\n  var history = useRef([]); // Keep history of promises\n  // Handle unmount\n  useEffect(function () {\n    return function () {\n      if (!keepAlive) {\n        cancellablePromise.cancel();\n      }\n    };\n  }, [cancellablePromise, cancellablePromise.promise, keepAlive]);\n  // Await promise\n  useSingleton(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var data;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          setIsResolved(null);\n          setReturnValue(null);\n          _context.prev = 2;\n          _context.next = 5;\n          return cancellablePromise.promise;\n        case 5:\n          data = _context.sent;\n          setReturnValue(data);\n          setIsResolved(true);\n          history.current.push(cancellablePromise);\n          _context.next = 16;\n          break;\n        case 11:\n          _context.prev = 11;\n          _context.t0 = _context[\"catch\"](2);\n          setReturnValue(_context.t0);\n          setIsResolved(false);\n          history.current.push(cancellablePromise);\n        case 16:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[2, 11]]);\n  })), [cancellablePromise.promise]);\n  if (!children || !isThenable(promise)) {\n    return null;\n  }\n  if (isResolved === null) {\n    // Promise is pending\n    var hasFallback = React.Children.toArray(children).find(function (c) {\n      return c.type === Fallback;\n    });\n    return React.createElement(Fragment, null, hasFallback || null);\n  }\n  if (!isResolved) {\n    // Promise is fulfilled and rejected\n    var hasElse = React.Children.toArray(children).find(function (c) {\n      return c.type === Else;\n    });\n    if (!hasElse) return React.createElement(Fragment, null, null);\n    // Inject caught error\n    var elseElement = hasElse;\n    var hasElseProps = hasElse.props;\n    if (typeof hasElseProps.children === 'function') {\n      elseElement = _extends({}, hasElse, {\n        props: _extends({}, hasElseProps, {\n          children: function children() {\n            return hasElseProps.children(returnValue, history.current, cancellablePromise.promise);\n          }\n        })\n      });\n    }\n    return React.createElement(Fragment, null, elseElement);\n  }\n  // Promise is fulfilled and resolved\n  var hasThen = React.Children.toArray(children).find(function (c) {\n    return c.type === Then;\n  });\n  if (!hasThen) return React.createElement(Fragment, null, null);\n  // Inject promise return value\n  var thenElement = hasThen;\n  var hasThenProps = hasThen.props;\n  if (typeof hasThenProps.children === 'function') {\n    thenElement = _extends({}, hasThen, {\n      props: _extends({}, hasThenProps, {\n        children: function children() {\n          return hasThenProps.children(returnValue, history.current, cancellablePromise.promise);\n        }\n      })\n    });\n  }\n  return React.createElement(Fragment, null, thenElement);\n}\n\n/**\n * Resolves a condition that is {@link BooleanLike} or returns {@link BooleanLike} from a function\n * @param condition The condition to resolve\n */\nvar getConditionResult = function getConditionResult(condition) {\n  var conditionResult = Boolean(typeof condition === 'function' ? condition() : condition);\n  return conditionResult;\n};\n\n/**\n * Handles errors by throwing them to the console.\n * `__DEV__` is replaced by dts-cli using {@link https://www.npmjs.com/package/babel-plugin-dev-expression babel-plugin-dev-expressions}\n * which will ensure this entire throw is not present in production\n * @param condition The condition to check\n * @param message The message to throw if `condition` resolves to `true`\n */\nfunction tinyWarning(condition, message) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (condition) {\n      // check console for IE9 support which provides console\n      // only with open devtools\n      if (typeof console !== 'undefined') {\n        console.warn(message);\n      }\n      // Throwing an error and catching it immediately to improve debugging\n      // Users can utilize 'pause on caught exceptions' to get into this throw\n      try {\n        throw new Error(message);\n      } catch (x) {\n        // noop\n      }\n    }\n  }\n}\n\n/**\n * If condition evaluates to true, renders the `<Then />` block will be rendered,\n * otherwise renders the `<Else />` block. Either block may be omitted.\n *\n * This component can contain any number of `<Then />` or `<Else />` blocks,\n * but only the first block of the right type (either Then or Else, depending on the condition) will be rendered.\n * @param __namedParameters The props to pass down to the `<IF />` component, see {@link ComponentWithConditionProps}\n */\nvar If = function If(_ref) {\n  var condition = _ref.condition,\n    _ref$keepAlive = _ref.keepAlive,\n    keepAlive = _ref$keepAlive === void 0 ? false : _ref$keepAlive,\n    children = _ref.children;\n  if (!children) {\n    return null;\n  }\n  tinyWarning(!Array.isArray(children) && !(children.type === Else || children.type === Then) || !React__default.Children.toArray(children).every(function (child) {\n    return child.type === Else || child.type === Then || child.type === Fallback;\n  }), 'The <If> component should contain <Then /> <Else /> or <Fallback /> components as its children');\n  if (isThenable(condition)) {\n    return React__default.createElement(IfAsync, {\n      promise: condition,\n      keepAlive: keepAlive\n    }, children);\n  }\n  var conditionResult = getConditionResult(condition);\n  return React__default.createElement(Fragment, null, React__default.Children.toArray(children).find(function (c) {\n    return c.type !== Else !== !conditionResult;\n  }) || null);\n};\n\n/**\n * It will render the first matching `<Case />`, or the first encountered `<Default />` (or `null`).\n *\n * This component can contain any number of `<Case />` and one `<Default />` blocks\n * @param __namedParameters Children to pass into the `<Switch />` component\n */\nvar Switch = function Switch(_ref) {\n  var _ref2;\n  var children = _ref.children;\n  // -- Inspired by react-router --\n  // We use React.Children.forEach instead of React.Children.toArray().find()\n  // here because toArray adds keys to all child elements and we do not want\n  // to trigger an unmount/remount for two children <Case>s or <Default>s\n  var matchingCase = undefined;\n  var defaultCase = undefined;\n  // If the children are a function then resolve it first\n  if (isFunction(children)) {\n    children = children();\n  }\n  React.Children.forEach(children, function (child) {\n    // not a valid react child, don't add it\n    /* istanbul ignore next - This is only a safe fail for people writing bad code */\n    if (!React.isValidElement(child)) {\n      return;\n    }\n    if (!matchingCase && child.type === Case) {\n      var childProps = child.props;\n      var conditionResult = getConditionResult(childProps.condition);\n      if (conditionResult) {\n        matchingCase = child;\n      } // else not matching condition, don't add it\n    } else if (!defaultCase && child.type === Default) {\n      defaultCase = child;\n    } // else unknown type, don't add it\n  });\n  return (_ref2 = matchingCase != null ? matchingCase : defaultCase) != null ? _ref2 : null;\n};\n\n/** A shorthand for\n *\n * ```jsx\n * <If condition={...}>\n *     <Else>\n *         { ... }\n *     </Else>\n * </If>\n * ```\n *\n * The same rules apply to the child elements as with using the `<Else />` block.\n *\n * @param __namedParameters The props to pass down to the `<IF />` component, see {@link ComponentWithConditionProps}\n */\nvar Unless = function Unless(_ref) {\n  var condition = _ref.condition,\n    _ref$children = _ref.children,\n    children = _ref$children === void 0 ? null : _ref$children;\n  var conditionResult = Boolean(getConditionResult(condition));\n  return !conditionResult && children ? render({\n    children: children\n  }) : null;\n};\n\n/** A shorthand for\n *\n * ```jsx\n * <If condition={...}>\n *     <Then>\n *         { ... }\n *     </Then>\n * </If>\n * ```\n *\n * The same rules apply to the child elements as with using the `<Then /`> block.\n *\n * @param __namedParameters The props to pass down to the `<IF />` component, see {@link ComponentWithConditionProps}\n */\nvar When = function When(_ref) {\n  var condition = _ref.condition,\n    _ref$children = _ref.children,\n    children = _ref$children === void 0 ? null : _ref$children;\n  var conditionResult = Boolean(getConditionResult(condition));\n  return conditionResult && children ? render({\n    children: children\n  }) : null;\n};\nexport { Case, Default, Else, Fallback, If, Switch, Then, Unless, When };","map":{"version":3,"names":["render","props","children","React__default","createElement","Fragment","Case","_ref","_ref$children","Default","Else","Fallback","Then","isFunction","input","hasThen","Reflect","has","then","hasCatch","isThenable","Promise","prototype","shallowArraysEqual","a","b","Array","isArray","Error","length","i","createCancellablePromise","promise","isCancelled","value","wrappedPromise","_asyncToGenerator","_regeneratorRuntime","mark","_callee","res","rej","d","wrap","_callee$","_context","prev","next","sent","t0","stop","_x","_x2","apply","arguments","Object","keys","forEach","key","cancel","useSingleton","callback","dependencies","hasRan","useRef","lastDependencies","hasDependencies","hasAnyDependencyChanged","current","IfAsync","_ref$keepAlive","keepAlive","_useState","useState","isResolved","setIsResolved","_useState2","returnValue","setReturnValue","cancellablePromise","useMemo","history","useEffect","data","push","hasFallback","React","Children","toArray","find","c","type","hasElse","elseElement","hasElseProps","_extends","thenElement","hasThenProps","getConditionResult","condition","conditionResult","Boolean","tinyWarning","message","process","env","NODE_ENV","console","warn","x","If","every","child","Switch","_ref2","matchingCase","undefined","defaultCase","isValidElement","childProps","Unless","When"],"sources":["/home/qxie/401/class-32/solution/node_modules/react-if/src/render.tsx","/home/qxie/401/class-32/solution/node_modules/react-if/src/Case.tsx","/home/qxie/401/class-32/solution/node_modules/react-if/src/Default.tsx","/home/qxie/401/class-32/solution/node_modules/react-if/src/Else.tsx","/home/qxie/401/class-32/solution/node_modules/react-if/src/Fallback.tsx","/home/qxie/401/class-32/solution/node_modules/react-if/src/Then.tsx","/home/qxie/401/class-32/solution/node_modules/react-if/src/isThenable.ts","/home/qxie/401/class-32/solution/node_modules/react-if/src/utils.ts","/home/qxie/401/class-32/solution/node_modules/react-if/src/hooks.ts","/home/qxie/401/class-32/solution/node_modules/react-if/src/IfAsync.tsx","/home/qxie/401/class-32/solution/node_modules/react-if/src/getConditionResults.ts","/home/qxie/401/class-32/solution/node_modules/react-if/src/tinyWarning.ts","/home/qxie/401/class-32/solution/node_modules/react-if/src/If.tsx","/home/qxie/401/class-32/solution/node_modules/react-if/src/Switch.tsx","/home/qxie/401/class-32/solution/node_modules/react-if/src/Unless.tsx","/home/qxie/401/class-32/solution/node_modules/react-if/src/When.tsx"],"sourcesContent":["import React, { Fragment } from 'react';\nimport type { FCWithImplicitChildren } from './types';\n\n/**\n * Renders a React component while also checking whether the children are a function or not\n * @param props Props of the component to render\n */\nexport const render: FCWithImplicitChildren = (props) => {\n  if (typeof props.children === 'function') {\n    return <Fragment>{props.children()}</Fragment>;\n  }\n\n  return <Fragment>{props.children || null}</Fragment>;\n};\n","import type { FC } from 'react';\nimport { render } from './render';\nimport type { ComponentWithConditionPropsWithFunctionChildren } from './types';\n\n/**\n * If the `<Case />` is the first one to have its condition evaluates to true\n * inside the parent `<Switch />` it will be the only rendered.\n * @param props The props to pass down to the `<Case />` component\n */\nexport const Case: FC<ComponentWithConditionPropsWithFunctionChildren> = ({ children = null }) => {\n  return render({ children });\n};\n","import { render } from './render';\nimport type { FCWithImplicitChildren } from './types';\n\n/**\n * If no `<Case />` have its condition evaluates to true inside the parent `<Switch />`,\n * the first `<Default />` will be the only one rendered.\n * @param props The props to pass down to the `<Default />` component\n */\nexport const Default: FCWithImplicitChildren = ({ children = null }) => {\n  return render({ children });\n};\n","import { render } from './render';\nimport type { FCWithImplicitChildren } from './types';\n\n/**\n * Must only contain a single child, which it renders as-is.\n * Should not be used outside of an `<If />` block.\n * @param props The props to pass down to the `<Else />` component\n */\nexport const Else: FCWithImplicitChildren = (props) => render(props);\n","import { render } from './render';\nimport type { FCWithImplicitChildren } from './types';\n\n/**\n * Must contain only a single child, which it renders as-is.\n * Should not be used outside of an `<If />` block whose condition prop is a promise.\n * @param props The props to pass down to the `<Fallback />` component\n */\nexport const Fallback: FCWithImplicitChildren = (props) => render(props);\n","import { render } from './render';\nimport type { FCWithImplicitChildren } from './types';\n\n/**\n * Must contain only a single child, which it renders as-is.\n * Should not be used outside of an `<If />` block.\n * @param props The props to pass down to the `<Then />` component\n */\nexport const Then: FCWithImplicitChildren = (props) => render(props);\n","/**\n * The MIT License (MIT)\n *\n * Copyright © `2020` `The Sapphire Community and its contributors`\n *\n * Source: https://github.com/sapphiredev/utilities/blob/main/packages/utilities/src/lib/isThenable.ts\n * Full license: https://github.com/sapphiredev/utilities/blob/main/LICENSE.md\n */\n\n/* eslint-disable @typescript-eslint/no-unsafe-function-type */\n\ninterface Thenable {\n  then: Function;\n  catch: Function;\n}\n\n/**\n * Verify if the input is a function.\n * @param input The function to verify\n */\n\nexport function isFunction(input: unknown): input is Function {\n  return typeof input === 'function';\n}\n\nfunction hasThen(input: { then?: Function }): boolean {\n  return Reflect.has(input, 'then') && isFunction(input.then);\n}\n\nfunction hasCatch(input: { catch?: Function }): boolean {\n  return Reflect.has(input, 'catch') && isFunction(input.catch);\n}\n\n/**\n * Verify if an object is a promise.\n * @param input The promise to verify\n */\nexport function isThenable(input: unknown): input is Thenable {\n  if (typeof input !== 'object' || input === null) return false;\n  return input instanceof Promise || (input !== Promise.prototype && hasThen(input) && hasCatch(input));\n}\n","import { isThenable } from './isThenable';\nimport type { CancellablePromise, ExtendablePromise } from './types';\n\n/**\n * Compare two arrays without checking for possible nested properties\n * @param a Array to compare with b\n * @param b Array to compare with a\n * @returns True if arrays are identical, false if they are different\n */\nexport const shallowArraysEqual = (a: any[], b: any[]): boolean => {\n  if (!Array.isArray(a) || !Array.isArray(b)) throw new Error('shallowArraysEqual only accepts arrays as parameters');\n  if (a.length !== b.length) return false;\n\n  for (let i = 0; i < a.length; ++i) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n};\n\n/**\n * Create a CancellablePromise from a native Promise\n * @param promise The promise object to wrap\n * @returns Return value is an object of type CancellablePromise, with 2 properties:\n * - promise: a promise that can be left pending\n * - cancel: the function to use for cancelling the returned promise\n */\nexport const createCancellablePromise = <T>(promise: ExtendablePromise<T>): CancellablePromise => {\n  if (!isThenable(promise)) {\n    throw new Error('Argument of createCancellablePromise should be a Promise');\n  }\n\n  const isCancelled = { value: false };\n\n  const wrappedPromise: ExtendablePromise<T> = new Promise(async (res, rej) => {\n    try {\n      const d = await promise;\n      if (!isCancelled.value) {\n        res(d);\n      }\n    } catch (error) {\n      if (!isCancelled.value) {\n        rej(error);\n      }\n    }\n  });\n\n  // Forward potential additional properties\n  Object.keys(promise).forEach((key) => {\n    wrappedPromise[key] = promise[key];\n  });\n\n  return {\n    promise: wrappedPromise,\n    cancel: () => {\n      isCancelled.value = true;\n    }\n  };\n};\n","import { useRef } from 'react';\nimport { shallowArraysEqual } from './utils';\n\n/**\n * Calls a function only once during component lifecycle;\n * When dependency array is provided, will call the function again if at least one of the dependencies changed\n * @param callback The function to execute only once\n * @param dependencies A list of dependencies whose value, if changed since last call,\n * will trigger the execution of the callback\n */\nexport const useSingleton = (callback: () => any, dependencies: any[] = []) => {\n  const hasRan = useRef<boolean>(false);\n  const lastDependencies = useRef<any[]>([]);\n\n  // Parameters type check\n  if (typeof callback !== 'function') {\n    throw new Error(`Incorrect callback parameter for useSingleton hook; expected a function, but got: '${typeof callback}'.`);\n  }\n  if (!Array.isArray(dependencies)) {\n    throw new Error(`Incorrect dependencies parameter for useSingleton; expected an array, but got: '${typeof dependencies}'.`);\n  }\n\n  const hasDependencies = Array.isArray(dependencies) && dependencies.length > 0;\n  if (hasDependencies) {\n    // Has dependencies\n    const hasAnyDependencyChanged = !shallowArraysEqual(lastDependencies.current, dependencies);\n    if (hasAnyDependencyChanged) {\n      // Any dep has changed => overwrite last dependencies and execute callback\n      lastDependencies.current = dependencies;\n    } else if (hasRan.current) {\n      // No dep has changed => same behaviour as if no dependencies\n      return;\n    }\n  } else if (hasRan.current) {\n    // No dependencies\n    return;\n  }\n\n  callback();\n  hasRan.current = true;\n};\n","import * as React from 'react';\nimport { Fragment, useEffect, useMemo, useRef, useState, type PropsWithChildren, type ReactElement } from 'react';\nimport { Else } from './Else';\nimport { Fallback } from './Fallback';\nimport { Then } from './Then';\nimport { useSingleton } from './hooks';\nimport { isThenable } from './isThenable';\nimport type { AsyncSupportProps, CancellablePromise, ExtendablePromise } from './types';\nimport { createCancellablePromise } from './utils';\n\n/**\n * Props for IfAsync\n */\ninterface Props<T> extends AsyncSupportProps, PropsWithChildren<{ promise: ExtendablePromise<T> }> {}\n\n/**\n * Is included in the `<If />` component, rendered when the condition prop of `<If />` is a Promise;\n * Renders the Fallback component, if contains any, until provided promise is fulfilled;\n * Renders `<Then />` when promise is fulfilled, `<Else />` when rejected\n */\n\nexport function IfAsync<T = any>({ promise, keepAlive = false, children }: Props<T>) {\n  const [isResolved, setIsResolved] = useState<null | boolean>(null);\n  const [returnValue, setReturnValue] = useState(null);\n\n  // Make promise cancellable\n  const cancellablePromise = useMemo((): CancellablePromise => createCancellablePromise(promise), [promise]);\n  const history = useRef<CancellablePromise[]>([]); // Keep history of promises\n\n  // Handle unmount\n  useEffect(() => {\n    return () => {\n      if (!keepAlive) {\n        cancellablePromise.cancel();\n      }\n    };\n  }, [cancellablePromise, cancellablePromise.promise, keepAlive]);\n\n  // Await promise\n  useSingleton(async () => {\n    setIsResolved(null);\n    setReturnValue(null);\n\n    try {\n      const data = await cancellablePromise.promise;\n      setReturnValue(data);\n      setIsResolved(true);\n      history.current.push(cancellablePromise);\n    } catch (error) {\n      setReturnValue(error as any);\n      setIsResolved(false);\n      history.current.push(cancellablePromise);\n    }\n  }, [cancellablePromise.promise]);\n\n  if (!children || !isThenable(promise)) {\n    return null;\n  }\n\n  if (isResolved === null) {\n    // Promise is pending\n    const hasFallback = (React.Children.toArray(children) as ReactElement[]).find((c) => c.type === Fallback);\n    return <Fragment>{hasFallback || null}</Fragment>;\n  }\n\n  if (!isResolved) {\n    // Promise is fulfilled and rejected\n    const hasElse = (React.Children.toArray(children) as ReactElement[]).find((c) => c.type === Else);\n    if (!hasElse) return <Fragment>{null}</Fragment>;\n\n    // Inject caught error\n    let elseElement = hasElse;\n    const hasElseProps = hasElse.props as { children: any };\n    if (typeof hasElseProps.children === 'function') {\n      elseElement = {\n        ...hasElse,\n        props: {\n          ...hasElseProps,\n          children: () => hasElseProps.children(returnValue, history.current, cancellablePromise.promise)\n        }\n      };\n    }\n    return <Fragment>{elseElement}</Fragment>;\n  }\n\n  // Promise is fulfilled and resolved\n  const hasThen = (React.Children.toArray(children) as ReactElement[]).find((c) => c.type === Then);\n  if (!hasThen) return <Fragment>{null}</Fragment>;\n\n  // Inject promise return value\n  let thenElement = hasThen;\n  const hasThenProps = hasThen.props as { children: any };\n  if (typeof hasThenProps.children === 'function') {\n    thenElement = {\n      ...hasThen,\n      props: {\n        ...hasThenProps,\n        children: () => hasThenProps.children(returnValue, history.current, cancellablePromise.promise)\n      }\n    };\n  }\n\n  return <Fragment>{thenElement}</Fragment>;\n}\n","import type { BooleanLike } from './types';\n\n/**\n * Resolves a condition that is {@link BooleanLike} or returns {@link BooleanLike} from a function\n * @param condition The condition to resolve\n */\nexport const getConditionResult = (condition: BooleanLike | ((...args: unknown[]) => BooleanLike)): boolean => {\n  const conditionResult = Boolean(typeof condition === 'function' ? condition() : condition);\n\n  return conditionResult;\n};\n","/**\n * Handles errors by throwing them to the console.\n * `__DEV__` is replaced by dts-cli using {@link https://www.npmjs.com/package/babel-plugin-dev-expression babel-plugin-dev-expressions}\n * which will ensure this entire throw is not present in production\n * @param condition The condition to check\n * @param message The message to throw if `condition` resolves to `true`\n */\nexport function tinyWarning(condition: boolean, message: string): asserts condition {\n  if (__DEV__) {\n    if (condition) {\n      // check console for IE9 support which provides console\n      // only with open devtools\n\n      if (typeof console !== 'undefined') {\n        console.warn(message);\n      }\n\n      // Throwing an error and catching it immediately to improve debugging\n      // Users can utilize 'pause on caught exceptions' to get into this throw\n      try {\n        throw new Error(message);\n      } catch (x) {\n        // noop\n      }\n    }\n  }\n}\n\ndeclare global {\n  let __DEV__: boolean;\n}\n","import React, { Fragment, type FC, type ReactElement } from 'react';\nimport { Else } from './Else';\nimport { Fallback } from './Fallback';\nimport { IfAsync } from './IfAsync';\nimport { Then } from './Then';\nimport { getConditionResult } from './getConditionResults';\nimport { isThenable } from './isThenable';\nimport { tinyWarning } from './tinyWarning';\nimport type { ComponentWithConditionPropsAsyncSupport, ExtendablePromise } from './types';\n\n/**\n * If condition evaluates to true, renders the `<Then />` block will be rendered,\n * otherwise renders the `<Else />` block. Either block may be omitted.\n *\n * This component can contain any number of `<Then />` or `<Else />` blocks,\n * but only the first block of the right type (either Then or Else, depending on the condition) will be rendered.\n * @param __namedParameters The props to pass down to the `<IF />` component, see {@link ComponentWithConditionProps}\n */\nexport const If: FC<ComponentWithConditionPropsAsyncSupport> = ({ condition, keepAlive = false, children }) => {\n  if (!children) {\n    return null;\n  }\n\n  tinyWarning(\n    (!Array.isArray(children) && !((children as ReactElement).type === Else || (children as ReactElement).type === Then)) ||\n      !(React.Children.toArray(children) as ReactElement[]).every((child) => child.type === Else || child.type === Then || child.type === Fallback),\n    'The <If> component should contain <Then /> <Else /> or <Fallback /> components as its children'\n  );\n\n  if (isThenable(condition)) {\n    return (\n      <IfAsync promise={condition as ExtendablePromise<any>} keepAlive={keepAlive}>\n        {children}\n      </IfAsync>\n    );\n  }\n\n  const conditionResult = getConditionResult(condition);\n\n  return <Fragment>{(React.Children.toArray(children) as ReactElement[]).find((c) => (c.type !== Else) !== !conditionResult) || null}</Fragment>;\n};\n","import * as React from 'react';\nimport { type ReactElement } from 'react';\nimport { Case } from './Case';\nimport { Default } from './Default';\nimport { getConditionResult } from './getConditionResults';\nimport { isFunction } from './isThenable';\nimport type { FCWithImplicitChildren } from './types';\n\n/**\n * It will render the first matching `<Case />`, or the first encountered `<Default />` (or `null`).\n *\n * This component can contain any number of `<Case />` and one `<Default />` blocks\n * @param __namedParameters Children to pass into the `<Switch />` component\n */\nexport const Switch: FCWithImplicitChildren = ({ children }) => {\n  // -- Inspired by react-router --\n\n  // We use React.Children.forEach instead of React.Children.toArray().find()\n  // here because toArray adds keys to all child elements and we do not want\n  // to trigger an unmount/remount for two children <Case>s or <Default>s\n  let matchingCase: ReactElement | undefined = undefined;\n  let defaultCase: ReactElement | undefined = undefined;\n\n  // If the children are a function then resolve it first\n  if (isFunction(children)) {\n    children = children();\n  }\n\n  React.Children.forEach(children, (child) => {\n    // not a valid react child, don't add it\n    /* istanbul ignore next - This is only a safe fail for people writing bad code */\n    if (!React.isValidElement(child)) {\n      return;\n    }\n\n    if (!matchingCase && child.type === Case) {\n      const childProps = child.props as any;\n      const conditionResult = getConditionResult(childProps.condition);\n\n      if (conditionResult) {\n        matchingCase = child;\n      } // else not matching condition, don't add it\n    } else if (!defaultCase && child.type === Default) {\n      defaultCase = child;\n    } // else unknown type, don't add it\n  });\n\n  return matchingCase ?? defaultCase ?? null;\n};\n","import type { FC } from 'react';\nimport { getConditionResult } from './getConditionResults';\nimport { render } from './render';\nimport type { ComponentWithConditionPropsWithFunctionChildren } from './types';\n\n/** A shorthand for\n *\n * ```jsx\n * <If condition={...}>\n *     <Else>\n *         { ... }\n *     </Else>\n * </If>\n * ```\n *\n * The same rules apply to the child elements as with using the `<Else />` block.\n *\n * @param __namedParameters The props to pass down to the `<IF />` component, see {@link ComponentWithConditionProps}\n */\nexport const Unless: FC<ComponentWithConditionPropsWithFunctionChildren> = ({ condition, children = null }) => {\n  const conditionResult = Boolean(getConditionResult(condition));\n\n  return !conditionResult && children ? render({ children }) : null;\n};\n","import type { FC } from 'react';\nimport { getConditionResult } from './getConditionResults';\nimport { render } from './render';\nimport type { ComponentWithConditionPropsWithFunctionChildren } from './types';\n\n/** A shorthand for\n *\n * ```jsx\n * <If condition={...}>\n *     <Then>\n *         { ... }\n *     </Then>\n * </If>\n * ```\n *\n * The same rules apply to the child elements as with using the `<Then /`> block.\n *\n * @param __namedParameters The props to pass down to the `<IF />` component, see {@link ComponentWithConditionProps}\n */\nexport const When: FC<ComponentWithConditionPropsWithFunctionChildren> = ({ condition, children = null }) => {\n  const conditionResult = Boolean(getConditionResult(condition));\n\n  return conditionResult && children ? render({ children }) : null;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}