{"version":3,"file":"react-if.cjs.production.min.js","sources":["../src/render.tsx","../src/Case.tsx","../src/Default.tsx","../src/Else.tsx","../src/Fallback.tsx","../src/Then.tsx","../src/isThenable.ts","../src/IfAsync.tsx","../src/utils.ts","../src/hooks.ts","../src/getConditionResults.ts","../src/If.tsx","../src/Switch.tsx","../src/Unless.tsx","../src/When.tsx"],"sourcesContent":["import React, { Fragment } from 'react';\nimport type { FCWithImplicitChildren } from './types';\n\n/**\n * Renders a React component while also checking whether the children are a function or not\n * @param props Props of the component to render\n */\nexport const render: FCWithImplicitChildren = (props) => {\n  if (typeof props.children === 'function') {\n    return <Fragment>{props.children()}</Fragment>;\n  }\n\n  return <Fragment>{props.children || null}</Fragment>;\n};\n","import type { FC } from 'react';\nimport { render } from './render';\nimport type { ComponentWithConditionPropsWithFunctionChildren } from './types';\n\n/**\n * If the `<Case />` is the first one to have its condition evaluates to true\n * inside the parent `<Switch />` it will be the only rendered.\n * @param props The props to pass down to the `<Case />` component\n */\nexport const Case: FC<ComponentWithConditionPropsWithFunctionChildren> = ({ children = null }) => {\n  return render({ children });\n};\n","import { render } from './render';\nimport type { FCWithImplicitChildren } from './types';\n\n/**\n * If no `<Case />` have its condition evaluates to true inside the parent `<Switch />`,\n * the first `<Default />` will be the only one rendered.\n * @param props The props to pass down to the `<Default />` component\n */\nexport const Default: FCWithImplicitChildren = ({ children = null }) => {\n  return render({ children });\n};\n","import { render } from './render';\nimport type { FCWithImplicitChildren } from './types';\n\n/**\n * Must only contain a single child, which it renders as-is.\n * Should not be used outside of an `<If />` block.\n * @param props The props to pass down to the `<Else />` component\n */\nexport const Else: FCWithImplicitChildren = (props) => render(props);\n","import { render } from './render';\nimport type { FCWithImplicitChildren } from './types';\n\n/**\n * Must contain only a single child, which it renders as-is.\n * Should not be used outside of an `<If />` block whose condition prop is a promise.\n * @param props The props to pass down to the `<Fallback />` component\n */\nexport const Fallback: FCWithImplicitChildren = (props) => render(props);\n","import { render } from './render';\nimport type { FCWithImplicitChildren } from './types';\n\n/**\n * Must contain only a single child, which it renders as-is.\n * Should not be used outside of an `<If />` block.\n * @param props The props to pass down to the `<Then />` component\n */\nexport const Then: FCWithImplicitChildren = (props) => render(props);\n","/**\n * The MIT License (MIT)\n *\n * Copyright Â© `2020` `The Sapphire Community and its contributors`\n *\n * Source: https://github.com/sapphiredev/utilities/blob/main/packages/utilities/src/lib/isThenable.ts\n * Full license: https://github.com/sapphiredev/utilities/blob/main/LICENSE.md\n */\n\n/* eslint-disable @typescript-eslint/no-unsafe-function-type */\n\ninterface Thenable {\n  then: Function;\n  catch: Function;\n}\n\n/**\n * Verify if the input is a function.\n * @param input The function to verify\n */\n\nexport function isFunction(input: unknown): input is Function {\n  return typeof input === 'function';\n}\n\nfunction hasThen(input: { then?: Function }): boolean {\n  return Reflect.has(input, 'then') && isFunction(input.then);\n}\n\nfunction hasCatch(input: { catch?: Function }): boolean {\n  return Reflect.has(input, 'catch') && isFunction(input.catch);\n}\n\n/**\n * Verify if an object is a promise.\n * @param input The promise to verify\n */\nexport function isThenable(input: unknown): input is Thenable {\n  if (typeof input !== 'object' || input === null) return false;\n  return input instanceof Promise || (input !== Promise.prototype && hasThen(input) && hasCatch(input));\n}\n","import * as React from 'react';\nimport { Fragment, useEffect, useMemo, useRef, useState, type PropsWithChildren, type ReactElement } from 'react';\nimport { Else } from './Else';\nimport { Fallback } from './Fallback';\nimport { Then } from './Then';\nimport { useSingleton } from './hooks';\nimport { isThenable } from './isThenable';\nimport type { AsyncSupportProps, CancellablePromise, ExtendablePromise } from './types';\nimport { createCancellablePromise } from './utils';\n\n/**\n * Props for IfAsync\n */\ninterface Props<T> extends AsyncSupportProps, PropsWithChildren<{ promise: ExtendablePromise<T> }> {}\n\n/**\n * Is included in the `<If />` component, rendered when the condition prop of `<If />` is a Promise;\n * Renders the Fallback component, if contains any, until provided promise is fulfilled;\n * Renders `<Then />` when promise is fulfilled, `<Else />` when rejected\n */\n\nexport function IfAsync<T = any>({ promise, keepAlive = false, children }: Props<T>) {\n  const [isResolved, setIsResolved] = useState<null | boolean>(null);\n  const [returnValue, setReturnValue] = useState(null);\n\n  // Make promise cancellable\n  const cancellablePromise = useMemo((): CancellablePromise => createCancellablePromise(promise), [promise]);\n  const history = useRef<CancellablePromise[]>([]); // Keep history of promises\n\n  // Handle unmount\n  useEffect(() => {\n    return () => {\n      if (!keepAlive) {\n        cancellablePromise.cancel();\n      }\n    };\n  }, [cancellablePromise, cancellablePromise.promise, keepAlive]);\n\n  // Await promise\n  useSingleton(async () => {\n    setIsResolved(null);\n    setReturnValue(null);\n\n    try {\n      const data = await cancellablePromise.promise;\n      setReturnValue(data);\n      setIsResolved(true);\n      history.current.push(cancellablePromise);\n    } catch (error) {\n      setReturnValue(error as any);\n      setIsResolved(false);\n      history.current.push(cancellablePromise);\n    }\n  }, [cancellablePromise.promise]);\n\n  if (!children || !isThenable(promise)) {\n    return null;\n  }\n\n  if (isResolved === null) {\n    // Promise is pending\n    const hasFallback = (React.Children.toArray(children) as ReactElement[]).find((c) => c.type === Fallback);\n    return <Fragment>{hasFallback || null}</Fragment>;\n  }\n\n  if (!isResolved) {\n    // Promise is fulfilled and rejected\n    const hasElse = (React.Children.toArray(children) as ReactElement[]).find((c) => c.type === Else);\n    if (!hasElse) return <Fragment>{null}</Fragment>;\n\n    // Inject caught error\n    let elseElement = hasElse;\n    const hasElseProps = hasElse.props as { children: any };\n    if (typeof hasElseProps.children === 'function') {\n      elseElement = {\n        ...hasElse,\n        props: {\n          ...hasElseProps,\n          children: () => hasElseProps.children(returnValue, history.current, cancellablePromise.promise)\n        }\n      };\n    }\n    return <Fragment>{elseElement}</Fragment>;\n  }\n\n  // Promise is fulfilled and resolved\n  const hasThen = (React.Children.toArray(children) as ReactElement[]).find((c) => c.type === Then);\n  if (!hasThen) return <Fragment>{null}</Fragment>;\n\n  // Inject promise return value\n  let thenElement = hasThen;\n  const hasThenProps = hasThen.props as { children: any };\n  if (typeof hasThenProps.children === 'function') {\n    thenElement = {\n      ...hasThen,\n      props: {\n        ...hasThenProps,\n        children: () => hasThenProps.children(returnValue, history.current, cancellablePromise.promise)\n      }\n    };\n  }\n\n  return <Fragment>{thenElement}</Fragment>;\n}\n","import { isThenable } from './isThenable';\nimport type { CancellablePromise, ExtendablePromise } from './types';\n\n/**\n * Compare two arrays without checking for possible nested properties\n * @param a Array to compare with b\n * @param b Array to compare with a\n * @returns True if arrays are identical, false if they are different\n */\nexport const shallowArraysEqual = (a: any[], b: any[]): boolean => {\n  if (!Array.isArray(a) || !Array.isArray(b)) throw new Error('shallowArraysEqual only accepts arrays as parameters');\n  if (a.length !== b.length) return false;\n\n  for (let i = 0; i < a.length; ++i) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n};\n\n/**\n * Create a CancellablePromise from a native Promise\n * @param promise The promise object to wrap\n * @returns Return value is an object of type CancellablePromise, with 2 properties:\n * - promise: a promise that can be left pending\n * - cancel: the function to use for cancelling the returned promise\n */\nexport const createCancellablePromise = <T>(promise: ExtendablePromise<T>): CancellablePromise => {\n  if (!isThenable(promise)) {\n    throw new Error('Argument of createCancellablePromise should be a Promise');\n  }\n\n  const isCancelled = { value: false };\n\n  const wrappedPromise: ExtendablePromise<T> = new Promise(async (res, rej) => {\n    try {\n      const d = await promise;\n      if (!isCancelled.value) {\n        res(d);\n      }\n    } catch (error) {\n      if (!isCancelled.value) {\n        rej(error);\n      }\n    }\n  });\n\n  // Forward potential additional properties\n  Object.keys(promise).forEach((key) => {\n    wrappedPromise[key] = promise[key];\n  });\n\n  return {\n    promise: wrappedPromise,\n    cancel: () => {\n      isCancelled.value = true;\n    }\n  };\n};\n","import { useRef } from 'react';\nimport { shallowArraysEqual } from './utils';\n\n/**\n * Calls a function only once during component lifecycle;\n * When dependency array is provided, will call the function again if at least one of the dependencies changed\n * @param callback The function to execute only once\n * @param dependencies A list of dependencies whose value, if changed since last call,\n * will trigger the execution of the callback\n */\nexport const useSingleton = (callback: () => any, dependencies: any[] = []) => {\n  const hasRan = useRef<boolean>(false);\n  const lastDependencies = useRef<any[]>([]);\n\n  // Parameters type check\n  if (typeof callback !== 'function') {\n    throw new Error(`Incorrect callback parameter for useSingleton hook; expected a function, but got: '${typeof callback}'.`);\n  }\n  if (!Array.isArray(dependencies)) {\n    throw new Error(`Incorrect dependencies parameter for useSingleton; expected an array, but got: '${typeof dependencies}'.`);\n  }\n\n  const hasDependencies = Array.isArray(dependencies) && dependencies.length > 0;\n  if (hasDependencies) {\n    // Has dependencies\n    const hasAnyDependencyChanged = !shallowArraysEqual(lastDependencies.current, dependencies);\n    if (hasAnyDependencyChanged) {\n      // Any dep has changed => overwrite last dependencies and execute callback\n      lastDependencies.current = dependencies;\n    } else if (hasRan.current) {\n      // No dep has changed => same behaviour as if no dependencies\n      return;\n    }\n  } else if (hasRan.current) {\n    // No dependencies\n    return;\n  }\n\n  callback();\n  hasRan.current = true;\n};\n","import type { BooleanLike } from './types';\n\n/**\n * Resolves a condition that is {@link BooleanLike} or returns {@link BooleanLike} from a function\n * @param condition The condition to resolve\n */\nexport const getConditionResult = (condition: BooleanLike | ((...args: unknown[]) => BooleanLike)): boolean => {\n  const conditionResult = Boolean(typeof condition === 'function' ? condition() : condition);\n\n  return conditionResult;\n};\n","import React, { Fragment, type FC, type ReactElement } from 'react';\nimport { Else } from './Else';\nimport { Fallback } from './Fallback';\nimport { IfAsync } from './IfAsync';\nimport { Then } from './Then';\nimport { getConditionResult } from './getConditionResults';\nimport { isThenable } from './isThenable';\nimport { tinyWarning } from './tinyWarning';\nimport type { ComponentWithConditionPropsAsyncSupport, ExtendablePromise } from './types';\n\n/**\n * If condition evaluates to true, renders the `<Then />` block will be rendered,\n * otherwise renders the `<Else />` block. Either block may be omitted.\n *\n * This component can contain any number of `<Then />` or `<Else />` blocks,\n * but only the first block of the right type (either Then or Else, depending on the condition) will be rendered.\n * @param __namedParameters The props to pass down to the `<IF />` component, see {@link ComponentWithConditionProps}\n */\nexport const If: FC<ComponentWithConditionPropsAsyncSupport> = ({ condition, keepAlive = false, children }) => {\n  if (!children) {\n    return null;\n  }\n\n  tinyWarning(\n    (!Array.isArray(children) && !((children as ReactElement).type === Else || (children as ReactElement).type === Then)) ||\n      !(React.Children.toArray(children) as ReactElement[]).every((child) => child.type === Else || child.type === Then || child.type === Fallback),\n    'The <If> component should contain <Then /> <Else /> or <Fallback /> components as its children'\n  );\n\n  if (isThenable(condition)) {\n    return (\n      <IfAsync promise={condition as ExtendablePromise<any>} keepAlive={keepAlive}>\n        {children}\n      </IfAsync>\n    );\n  }\n\n  const conditionResult = getConditionResult(condition);\n\n  return <Fragment>{(React.Children.toArray(children) as ReactElement[]).find((c) => (c.type !== Else) !== !conditionResult) || null}</Fragment>;\n};\n","import * as React from 'react';\nimport { type ReactElement } from 'react';\nimport { Case } from './Case';\nimport { Default } from './Default';\nimport { getConditionResult } from './getConditionResults';\nimport { isFunction } from './isThenable';\nimport type { FCWithImplicitChildren } from './types';\n\n/**\n * It will render the first matching `<Case />`, or the first encountered `<Default />` (or `null`).\n *\n * This component can contain any number of `<Case />` and one `<Default />` blocks\n * @param __namedParameters Children to pass into the `<Switch />` component\n */\nexport const Switch: FCWithImplicitChildren = ({ children }) => {\n  // -- Inspired by react-router --\n\n  // We use React.Children.forEach instead of React.Children.toArray().find()\n  // here because toArray adds keys to all child elements and we do not want\n  // to trigger an unmount/remount for two children <Case>s or <Default>s\n  let matchingCase: ReactElement | undefined = undefined;\n  let defaultCase: ReactElement | undefined = undefined;\n\n  // If the children are a function then resolve it first\n  if (isFunction(children)) {\n    children = children();\n  }\n\n  React.Children.forEach(children, (child) => {\n    // not a valid react child, don't add it\n    /* istanbul ignore next - This is only a safe fail for people writing bad code */\n    if (!React.isValidElement(child)) {\n      return;\n    }\n\n    if (!matchingCase && child.type === Case) {\n      const childProps = child.props as any;\n      const conditionResult = getConditionResult(childProps.condition);\n\n      if (conditionResult) {\n        matchingCase = child;\n      } // else not matching condition, don't add it\n    } else if (!defaultCase && child.type === Default) {\n      defaultCase = child;\n    } // else unknown type, don't add it\n  });\n\n  return matchingCase ?? defaultCase ?? null;\n};\n","import type { FC } from 'react';\nimport { getConditionResult } from './getConditionResults';\nimport { render } from './render';\nimport type { ComponentWithConditionPropsWithFunctionChildren } from './types';\n\n/** A shorthand for\n *\n * ```jsx\n * <If condition={...}>\n *     <Else>\n *         { ... }\n *     </Else>\n * </If>\n * ```\n *\n * The same rules apply to the child elements as with using the `<Else />` block.\n *\n * @param __namedParameters The props to pass down to the `<IF />` component, see {@link ComponentWithConditionProps}\n */\nexport const Unless: FC<ComponentWithConditionPropsWithFunctionChildren> = ({ condition, children = null }) => {\n  const conditionResult = Boolean(getConditionResult(condition));\n\n  return !conditionResult && children ? render({ children }) : null;\n};\n","import type { FC } from 'react';\nimport { getConditionResult } from './getConditionResults';\nimport { render } from './render';\nimport type { ComponentWithConditionPropsWithFunctionChildren } from './types';\n\n/** A shorthand for\n *\n * ```jsx\n * <If condition={...}>\n *     <Then>\n *         { ... }\n *     </Then>\n * </If>\n * ```\n *\n * The same rules apply to the child elements as with using the `<Then /`> block.\n *\n * @param __namedParameters The props to pass down to the `<IF />` component, see {@link ComponentWithConditionProps}\n */\nexport const When: FC<ComponentWithConditionPropsWithFunctionChildren> = ({ condition, children = null }) => {\n  const conditionResult = Boolean(getConditionResult(condition));\n\n  return conditionResult && children ? render({ children }) : null;\n};\n"],"names":["render","props","React","createElement","Fragment","children","Case","_ref","_ref$children","Default","Else","Fallback","Then","isFunction","input","isThenable","Promise","prototype","Reflect","has","then","hasThen","hasCatch","IfAsync","promise","_ref$keepAlive","keepAlive","_useState","useState","isResolved","setIsResolved","_useState2","returnValue","setReturnValue","cancellablePromise","useMemo","Error","isCancelled","value","wrappedPromise","_asyncToGenerator","_regeneratorRuntime","mark","_callee","res","rej","d","wrap","_context","prev","next","sent","t0","stop","_x","_x2","apply","this","arguments","Object","keys","forEach","key","cancel","createCancellablePromise","history","useRef","useEffect","callback","dependencies","hasRan","lastDependencies","Array","isArray","length","a","b","i","shallowArraysEqual","current","useSingleton","push","hasFallback","Children","toArray","find","c","type","hasElse","elseElement","hasElseProps","_extends","thenElement","hasThenProps","getConditionResult","condition","Boolean","every","child","conditionResult","_ref2","matchingCase","undefined","defaultCase","isValidElement"],"mappings":"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"}